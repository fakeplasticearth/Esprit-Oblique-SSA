---
title: ''
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

В этом файле хранятся функции, которые строят жорданов базис. Тестирование функций и примеры построения жорданового базиса находятся в файле jordan_research2.

```{r, message = FALSE, warning = FALSE}
  source("jordan_util.R")
  library(QZ)
  library(plotrix)
```

## Реализация EOSSA для случая кратных корней

```{r}
  plot_roots <- function(roots){
    plot(roots, asp = 1, xlim = c(-1,1), ylim = c(-1,1))  
    draw.circle(0,0,1,nv=1000,border=NULL,col=NA,lty=1,lwd=1)
  }

  eossa_exp <- function(ssa_obj, ecomp_num, cl_eps = 3e-4){
    w_length <- ssa_obj$window
    U <- ssa_obj$U[,1:ecomp_num]
    V <- ssa_obj$V[,1:ecomp_num]
    vals <- diag(ssa_obj$sigma[1:ecomp_num])
    
    P_low <- U[1:(w_length - 1),]
    P_up <- U[2:w_length,]
    M <- Rssa:::tls.solve(P_low, P_up) # Матрица сдвига
    
    dec <- eigen(M)
    #roots <- parestimate(ssa_obj, groups = list(1:ecomp_num), method = "esprit")$roots#
    roots <- dec$values
    plot_roots(roots)
    res <- clusterize_roots(roots, cl_eps)
    print("Корни")
    print(res$roots)
    print("Кратности")
    print(res$multiplicities)
    
    print("Разложение М")
    print(eigen(M)$values)
    
    basis <- get_all_basis(M, res$roots, res$multiplicities)
    
    if (nrow(basis$basis) > ncol(basis$basis)){
      print("Wrong basis")
      return(numeric(0))
    }
    
    jordan_basis <- basis$basis
    jordan_basis_inv <- qr.solve(jordan_basis)
    components <- list()
    
    left <- U %*% jordan_basis
    right <- numeric(0)
    if (is.complex(V))
      right <- jordan_basis_inv %*% vals %*% H(V)
    else
      right <- jordan_basis_inv %*% vals %*% t(V)
    
    prev_m <- 0
    left_side <- numeric(0)
    right_side <- numeric(0)
    
    for (i in 1:length(res$roots)){
      
      if (res$multiplicities[i] == 1){
        left_side <- matrix(left[,(1 + prev_m):(prev_m + 1)], ncol = 1)
        right_side <- matrix(right[(1 + prev_m):(prev_m + 1),], nrow = 1)
      }
      else{
        left_side <- left[,(1 + prev_m):(prev_m + res$multiplicities[i])]
        right_side <- right[(1 + prev_m):(prev_m + res$multiplicities[i]),]
      }
      
      components[[i]] <- Rssa::hankel(left_side %*% right_side)
      
      prev_m <- prev_m + res$multiplicities[i]
    }
    return(components)
  }
```


# Пример 1
Пусть будут три различных корня $\mu_1 = 0.75 - 0.63i, \mu_2 = 0.4 + 0.9i, \mu_3 = 0.5 - 0.87i$, при этом их кратности $m_1 = 4, m_2 = 2, m_3 = 1$. Построим ряд через ЛРФ.
```{r lrts}
  mu1 = 0.75 - 0.63i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.4 + 0.9i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.5 - 0.87i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return((2.5 + 0.5 * j + 1.5 * j ^ 2 - 3.4 * j ^ 3) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ( - 2.2 * mu3 ^ j)
  }
  
  time_series_function <- function(j) {
    return (comp1(j) + comp2(j) + comp3(j))
  }
```

```{r ts}
  time_series_stamps = 0:100
  time_series <- time_series_function(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 7)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[2]]) ^ 2) / length(time_series)))
```

Компоненты нашлись верно!

## Пример 2

Три различных корня $\mu_1 = 0.2 - 0.97i, \mu_2 = 0.63 + 0.63i, \mu_3 = 0.9 - 0.5i$, при этом их кратности $m_1 = 2, m_2 = 3, m_3 = 2$.
```{r}
  mu1 = 0.2 - 0.97i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.63 + 0.63i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.9 - 0.5i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.05 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((-2.2 + 0.8 * j) * mu3 ^ j)
  }
  time_series <- time_series_function(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 7)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[2]]) ^ 2) / length(time_series)))
```
Все компоненты нашлись верно.

## Пример 3

Построим тренд с помощью корня $\mu_1 = 0.12 - 1.03i$ кратности $m_1 = 1$, корня $\mu_2 = 0.63 + 0.63i$ кратности $m_2 = 3$ и корня $\mu_3 = 0.9 - 0.5i$ кратности $m_3 = 2$. Также добавим гармонику $0.5 \mathsf{cos}(\frac{2\pi n}{3})$.

```{r}
  mu1 = 0.12 - 1.03i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.63 + 0.63i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.9 - 0.5i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return(0.2 * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((0.7 - 0.08 * j) * mu3 ^ j)
  }
  
  comp4 <- function(j) {
    return (0.5 * cos(2 * pi * j / 3))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  plot(s, type = "vectors", idx = 1:8)
  
  res <- eossa_exp(s, 8)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[5]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[5]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 4
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] + res[[4]] - comps[[4]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] + res[[4]] - comps[[4]]) ^ 2) / length(time_series)))
```

Компоненты выделились верно.

## Пример 4. Проверка случая с простыми корнями
```{r}
  mu12 = 0.88 - 0.4i
  print(paste0("mu_1: ", mu12, ", Mod: ", Mod(mu12)))
  
  mu22 = 0.3 + 0.89i
  print(paste0("mu_2: ", mu22, ", Mod: ", Mod(mu22)))
  
  mu32 = 1.01 + 0.05i
  print(paste0("mu_3: ", mu32, ", Mod: ", Mod(mu32)))
  
  comp12 <- function(j) {
    return( -0.5 * mu12 ^ j)
  }
  
  comp22 <- function(j) {
    return(1.5 * mu22 ^ j)
  }
  
  comp32 <- function(j) {
    return ( - 0.02 * mu32 ^ j)
  }
  
  time_series_stamps = 0:100
  comps <- list()
  comps[[3]] <- comp12(time_series_stamps)
  comps[[2]] <- comp22(time_series_stamps)
  comps[[1]] <- comp32(time_series_stamps)

  time_series_function2 <- function(j){
    return (comp12(j) + comp22(j) + comp32(j))
  }  

  time_series2 <- time_series_function2(time_series_stamps)
  
  s2 <- ssa(time_series2, L = 48, svd.method = "svd")
  res <- eossa_exp(s2, 3)
  
  for (i in 1:length(res)){
    comp <- res[[i]]
    print(paste0("MSE: ", sum(abs(comps[[i]] - comp) ^ 2) / length(comp)))
  }
  
```

## Пример 5. Проверка случая с простыми корнями
```{r}
  mu1 = 0.5 - 0.93i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.72 + 0.7i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.74 - 0.62i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return(0.5 * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return(-1.2 * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ( - 2.2 * mu3 ^ j)
  }
  
  time_series <- time_series_function(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 3)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компоненты нашлись верно.

## Пример 6.

Попробуем посмотреть на разделение, когда размеры матрицы сдвига будут достаточно большими. Этот случай важен, так как при больших
размерах матрицы базис строится менее точно.

Построим тренд с помощью корня $\mu_1 = 0.24 - 0.93i$ кратности $m_1 = 2$, корня $\mu_2 = 0.72 + 0.7i$ кратности $m_2 = 3$, корня $m_3 = 0.5 - 0.865i$ кратности $m_3 = 2$ и корня $m_4 = 0.13 + 1.02i$ кратности $m_4 = 2$. Также добавим гармоники $0.5 \mathsf{cos}(\frac{2\pi n}{3})$ и $0.5 \mathsf{cos}(\frac{2\pi n}{4} + \frac{\pi}{2})$.

```{r}
  mu1 = 0.24 - 0.93i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.72 + 0.7i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.5 - 0.865i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  mu4 = 0.13 + 1.02i
  print(paste0("mu_3: ", mu4, ", Mod: ", Mod(mu4)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.05 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((-2.2 + 0.8 * j) * mu3 ^ j)
  }
  
  comp4 <- function(j) {
    return ((0.56 - 0.68 * j) * mu4 ^ j)
  }
  
  comp5 <- function(j) {
    return (0.5 * cos(2 * pi * j / 3))
  }
  
  comp6 <- function(j) {
    return (0.5 * cos(2 * pi * j / 4 + pi / 2))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps) + comp5(time_series_stamps) + comp6(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  comps[[5]] <- comp5(time_series_stamps)
  comps[[6]] <- comp6(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  res <- eossa_exp(s, 13)

```

В этом примере, кстати, есть недостаток разделимости компонент.

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[8]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[8]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 4
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[4]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[4]]) ^ 2) / length(time_series)))
```
Компонента 5
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[4]] + res[[7]] - comps[[5]]))))
  print(paste0("MSE: ", sum(abs(res[[4]] + res[[7]] - comps[[5]]) ^ 2) / length(time_series)))
```
Компонента 6
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[5]] + res[[6]] - comps[[6]]))))
  print(paste0("MSE: ", sum(abs(res[[5]] + res[[6]] - comps[[6]]) ^ 2) / length(time_series)))
```
Все компоненты нашлись верно.

## Пример 7.

Теперь попробуем посмотреть на разделение, когда размеры матрицы сдвига будут достаточно большими и при этом кратность одного корня тоже будет велика. Этот случай важен, так как при большой кратности корня матрица возводится в большую степень, соответственно ранг матрицы тяжелее оценить.

Построим тренд с помощью корня $\mu_1 = 0.74 - 0.65i$ кратности $m_1 = 6$ и корня $\mu_2 = 0.23 + 0.95i$ кратности $m_2 = 2$. Также добавим гармоники $-0.3 \mathsf{cos}(\frac{2\pi n}{6})$ и $-0.3 \mathsf{cos}(\frac{2\pi n}{3} + \frac{\pi}{4})$.

```{r}
  mu1 = 0.74 - 0.65i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.23 + 0.95i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.2 * j - 0.001 * j ^ 2 + 9e-4 * j ^ 3 - 2e-5 * j ^ 4 + 1.2e-7 * j ^ 5) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 0.11 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 6))
  }
  
  comp4 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 3 + pi / 4))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  source("jordan_util.R")
  print(get_roots_eig(s, 12)$roots)
  print(get_roots_eig(s, 12)$multiplicities)
  print(paste0("Расстояние между корнями: ", Mod(0.7392849-0.6497922i - (0.7407148-0.6502031i))))
  alg_root <- mean(c(0.7392588-0.6497611i, 0.7398371-0.6492407i, 0.7394233-0.6505245i, 0.7405740-0.6494789i, 0.7401672-0.6507600i, 0.7407396-0.6502349i))
  print(paste0("Корень при увеличении eps: ", alg_root))
  #res <- eossa_exp(s, 12)
```

Этот пример показал, что нужно увеличить eps для отбора корней в кластер, когда кратность корня большая. Однако мы не можем заранее сказать максимальную кратность корня, поэтому необходимо как-то разумно подобрать eps.

Расстояния между корнями разные. Влияет действительно только кратность, чем больше, тем больше расстояния. (Я пробовал посмотреть на расстояния между корнями без гармоник, та же ситуация). При этом если правильно составить кластер, корень найдется точно.

## Эксперимент с изменением расстояния между сигнальными корнями

Для того, чтобы улучшить результаты кластеризации, можно сделать вот что: посмотрим, при каком максимальном расстоянии между сигнальными корнями спектральное разложение будет выдавать неверные корни.

Модуль разности 0.01

```{r}
  mu1 = 0.74 - 0.65i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.74 - 0.66i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  print(paste0("Расстояние между корнями: ", Mod(mu1 - mu2)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.2 * j - 0.001 * j ^ 2 + 9e-4 * j ^ 3 - 2e-5 * j ^ 4 + 1.2e-7 * j ^ 5) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 0.11 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 6))
  }
  
  comp4 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 3 + pi / 4))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  roots <- get_roots_eig(s, 12)$roots
  print(roots)
  print(get_roots_eig(s, 12)$multiplicities)
  print(paste0("Максимальное расстояние между корнями в кластере первого корня: ", Mod(roots[2] - roots[7])))
  alg_root <- mean(roots[2:7])
  print(paste0("Ошибка нахождения первого корня при усреднении правильно найденного кластера: ", Mod(alg_root - mu1)))
```

Здесь второй корень невозможно корректно найти, так как спектральное разложение неверно его находит. Следовательно, если расстояние между сигнальными корнями меньше 0.01, то точно выделить компоненты не получится.

Далее сделаем так: в качестве второго корня возьмем первый, повернутый в полярной системе координат на такой угол (таким образом, модули корней равны), что расстояние между ними 0.02.

Модуль разности 0.02
```{r}
  mu1 = 0.74 - 0.65i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = mu1 * exp(1i * pi / 154)
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  print(paste0("Расстояние между корнями: ", Mod(mu1 - mu2)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.2 * j - 0.001 * j ^ 2 + 9e-4 * j ^ 3 - 2e-5 * j ^ 4 + 1.2e-7 * j ^ 5) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 0.11 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 6))
  }
  
  comp4 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 3 + pi / 4))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  roots <- get_roots_eig(s, 12)$roots
  print(roots)
  print(get_roots_eig(s, 12)$multiplicities)
  print(paste0("Максимальное расстояние между корнями в кластере первого корня: ", Mod(roots[2] - roots[7])))
  alg_root <- mean(roots[2:8][-c(4)])
  
  print(paste0("Ошибка нахождения первого корня при усреднении правильно найденного кластера: ", Mod(alg_root - mu1)))
```
Здесь второй корень снова находится спектральным разложением неверно.

Модуль разности 0.03
```{r}
  mu1 = 0.74 - 0.65i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = mu1 * exp(1i * pi / 103)
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  print(paste0("Расстояние между корнями: ", Mod(mu1 - mu2)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.2 * j - 0.001 * j ^ 2 + 9e-4 * j ^ 3 - 2e-5 * j ^ 4 + 1.2e-7 * j ^ 5) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 0.11 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 6))
  }
  
  comp4 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 3 + pi / 4))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  roots <- get_roots_eig(s, 12)$roots
  print(roots)
  print(get_roots_eig(s, 12)$multiplicities)
  print(paste0("Максимальное расстояние между корнями в кластере первого корня: ", Mod(roots[2] - roots[8])))
  alg_root1 <- mean(roots[2:8][-c(4)])
  
  print(paste0("Ошибка нахождения первого корня при усреднении правильно найденного кластера: ", Mod(alg_root1 - mu1)))
  
  print(paste0("Расстояние между корнями в кластере второго корня: ", Mod(roots[1] - roots[5])))
  alg_root2 <- mean(c(roots[1], roots[5]))
  print(paste0("Ошибка нахождения первого корня при усреднении правильно найденного кластера: ", Mod(alg_root2 - mu2)))
```
При таком расстоянии между сигнальными корнями второй корень уже находится точнее. Однако при этом расстояние между корнями в кластере первого корня увеличилось. Заметим, что расстояние между корнями в кластере все же меньше, чем расстояние между сигнальными корнями в модели. Следовательно, можно увеличить параметр $\varepsilon$ в кластеризации (теперь знаем, что для получения корней расстояния должны быть как минимум 0.03).

# Сравнение с EOSSA для простых корней

Попробуем понять в каких случаях обобщенный EOSSA будет лучше, чем обычный.

## Пример 1.

Составим для первого примера ряд, в модели которого кратности сигнальных корней небольшие. Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$. Также добавим гармонику $0.6 \mathsf{cos}(\frac{2\pi n}{4})$. 

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.6 * cos(2 * pi * j / 4))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp(s, 4, cl_eps = 1e-2)
  
  eossa_old <- eossa(s, nested.groups = list(1:4), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Посмотрим на ошибку для обычного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, первая выделенная компонента: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, вторая выделенная компонента: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Как можно увидеть, что EOSSA для простых корней точно идентифицировал компоненты.

Теперь посмотрим на ошибки обобщенного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[1]] + res_exp[[3]] - comps[[2]]))))
```
Компоненты найдены достаточно точно.

## Пример 2.

Посмотрим что будет, если в тренде только корень большой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 5$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. 

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j + 3e-4 * j ^ 2 - 4.5e-6 * j ^ 3 + 2.3e-8 * j ^ 4) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp(s, 7, cl_eps = 1e-2)
  
  eossa_old <- eossa(s, nested.groups = list(1:7), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Посмотрим на ошибки обычного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Компоненты найдены достаточно точно.

Теперт посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_exp[[1]] + res_exp[[3]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_exp[[2]] - comps[[1]]))))
```

Компоненты найдены достаточно точно.

## Пример 3.

Усложним задачу. Пусть теперь в можели тренда два сигнальных корня небольшой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$ и корня $\mu_2 = 1.02$ кратности $m_2 = 2$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. 

```{r}
  mu1 = 0.98
  
  mu2 = 1.02
  
  comp1 <- function(j) {
    return((5.3 - 0.03 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-2.7 + 0.08 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- time_series_function(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:6), k = 3, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  res_exp = eossa_exp(s, 6, cl_eps = 1e-2)
```

Посмотрим на ошибку для обычного EOSSA. Посмотрим насколько точно были идентифицированы компоненты тренда. Для удобства будем вычислять минимальную ошибку, сравнивая каждую выделенную компоненту с заданными компонентами.
```{r}
  min_err <- Inf
  print("Первая полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F1 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))

  min_err <- Inf

  print("Вторая полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F2 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Третья полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F3 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
```

Компоненты найдены достаточно точно.

Теперь посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[1]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[3]] + res_exp[[4]] - comps[[3]]))))
```
Компоненты найдены достаточно точно.

## Пример 4.

Еще раз усложним задачу. Построим тренд с помощью корня $\mu_1 = -0.92$ кратности $m_1 = 2$, корня $\mu_2 = 0.97$ кратности $m_2 = 4$ и корня $\mu_3 = -1.02$ кратности $m_3 = 4$. Также добавим гармоники $15.5 \mathsf{cos}(\frac{2\pi n}{12})$ и $20 \mathsf{cos}(\frac{2\pi n}{3} - \frac{\pi}{3})$. 

```{r}
  mu1 = -0.92
  
  mu2 = 0.97
  
  mu3 = -1.02
  
  comp1 <- function(j) {
    return((-25 - 0.33 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((22.9 - 0.4 * j + 4.5e-2 * j ^ 2 - 8e-4 * j ^ 3) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return((17 - 0.45 * j + 0.05 * j ^ 2 + 3.4e-4 * j ^ 3) * mu3 ^ j)
  }
  
  comp4 <- function(j){
    return(15.5 * cos(2 * pi * j / 12))
  }
  
  comp5 <- function(j){
    return(20 * cos(2 * pi * j / 3 - pi / 3))
  }
  
  time_series_stamps2 = 1:50
  time_series <- time_series_function(time_series_stamps2) + comp4(time_series_stamps2) + comp5(time_series_stamps2)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps2)
  comps[[2]] <- comp2(time_series_stamps2)
  comps[[3]] <- comp3(time_series_stamps2)
  comps[[4]] <- comp4(time_series_stamps2)
  comps[[5]] <- comp5(time_series_stamps2)
  
  s <- ssa(time_series, L = 24, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:14), k = 5, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  res_exp = eossa_exp(s, 14, cl_eps = 3e-2)
```

Посмотрим на ошибки обычного EOSSA.

```{r}
  min_err <- Inf
  print("Первая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F1 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))

  min_err <- Inf

  print("Вторая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F2 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Третья полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F3 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Четвертая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F4 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Пятая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F5 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
```

Гармоники выделились менее точно, чем компоненты тренда.

Посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[3]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[1]] - comps[[3]]))))
  print(paste0("Сумма модулей ошибок, идентификация четвертой компоненты: ", sum(abs(res_exp[[6]] + res_exp[[7]] - comps[[4]]))))
  print(paste0("Сумма модулей ошибок, идентификация пятой компоненты: ", sum(abs(res_exp[[4]] + res_exp[[5]] - comps[[5]]))))
```

Гармоники выделились точнее, чем в результате обычного EOSSA, при этом компоненты тренда менее точно.

## Пример 5.

Сравним методы на еще одном временном ряде со сложной структурой. Построим тренд с помощью корня $\mu_1 = 0.95$ кратности $m_1 = 2$ и корня $\mu_2 = 1.05$ кратности $m_2 = 2$. Также добавим домноженные на полином гармоники $(7 - 0.08n)\mathsf{cos}(\frac{2\pi n}{4} - \frac{2\pi n}{3})$ и $(7 - 0.08n + 3*10^{-3}n^2)\mathsf{cos}(\frac{2\pi n}{3})$, и гармонику $7 \mathsf{cos}(\frac{2\pi n}{6} - \frac{\pi}{4})$. 

```{r}
  mu1 = 0.95
  
  mu2 = 1.05
  
  comp1 <- function(j) {
    return((-12 - 0.43 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((22.9 - 0.4 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j){
    return((7 - 0.08 * j) * cos(2 * pi * j / 4 - pi / 3))
  }
  
  comp4 <- function(j){
    return((7 - 0.08 * j + 3e-3 * j ^ 2) * cos(2 * pi * j / 3))
  }
  
  comp5 <- function(j){
    return(7 * cos(2 * pi * j / 6 - pi / 4))
  }
  
  
  time_series_stamps2 = 1:50
  time_series <- time_series_function(time_series_stamps2) + comp4(time_series_stamps2) + comp5(time_series_stamps2)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps2)
  comps[[2]] <- comp2(time_series_stamps2)
  comps[[3]] <- comp3(time_series_stamps2)
  comps[[4]] <- comp4(time_series_stamps2)
  comps[[5]] <- comp5(time_series_stamps2)
  
  s <- ssa(time_series, L = 24, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:16), k = 5, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  res_exp = eossa_exp(s, 16, cl_eps = 3e-2)
```

Посмотрим на ошибки обычного EOSSA.

```{r}
  min_err <- Inf
  print("Первая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F1 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))

  min_err <- Inf

  print("Вторая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F2 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Третья полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F3 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
   min_err <- Inf

  print("Четвертая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F4 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Пятая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F5 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
```

Компоненты выделились точно.

Посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[1]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[5]] + res_exp[[6]] - comps[[3]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[3]] + res_exp[[4]] - comps[[4]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[7]] + res_exp[[8]] - comps[[5]]))))
```

Компоненты выделились немного точнее.

# Сравнение с шумом

## Пример 1.

Составим для первого примера ряд, в модели которого кратности сигнальных корней небольшие. Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$. Также добавим гармонику $0.6 \mathsf{cos}(\frac{2\pi n}{4})$. Также добавим белый гауссовский шум $\mathcal{N}(0, 0.05^2)$.

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.6 * cos(2 * pi * j / 4))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps) + rnorm(length(time_series_stamps), mean = 0, sd = 0.05)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp(s, 4, cl_eps = 3e-2)
  
  eossa_old <- eossa(s, nested.groups = list(1:4), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Видно, что при небольшом шуме уже кратные корни отклоняются от теоретической модели.

Посмотрим на ошибку для обычного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, первая выделенная компонента: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, вторая выделенная компонента: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Как можно увидеть, что EOSSA для простых корней получил достаточно большие ошибки.

Теперь посмотрим на ошибки обобщенного EOSSA.
```{r}
  if (length(res_exp) == 0){
    print("Неверное разложение.")
  } else{
    print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
    print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[1]] + res_exp[[3]] - comps[[2]]))))
  }
```
Разложение не было получено корректно.

## Пример 2.

Посмотрим что будет, если в тренде только корень большой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 5$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. Также добавим белый гауссовский шум $\mathcal{N}(0, 0.005^2)$.

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j + 3e-4 * j ^ 2 - 4.5e-6 * j ^ 3 + 2.3e-8 * j ^ 4) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps) + rnorm(length(time_series_stamps), mean = 0, sd = 0.005)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp(s, 7, cl_eps = 1e-2)
  
  eossa_old <- eossa(s, nested.groups = list(1:7), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Здесь добавление шума показало, что корень большой кратности при шуме вообще практически невозможно найти.

Посмотрим на ошибки обычного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Огромные ошибки.

Теперт посмотрим на ошибки обобщенного EOSSA.

```{r}
  if (length(res_exp) == 0){
    print("Неверное разложение.")
  } else{
     print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_exp[[1]] + res_exp[[3]] - comps[[2]]))))
    print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  }
```

Тоже огромные ошибки.

## Пример 3.

Усложним задачу. Пусть теперь в модели тренда два сигнальных корня небольшой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$ и корня $\mu_2 = 1.02$ кратности $m_2 = 2$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. Также добавим белый гауссовский шум $\mathcal{N}(0, 0.0005^2)$.

```{r}
  mu1 = 0.98
  
  mu2 = 1.02
  
  comp1 <- function(j) {
    return((5.3 - 0.03 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-2.7 + 0.08 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- time_series_function(time_series_stamps) + rnorm(length(time_series_stamps), mean = 0, sd = 0.0005)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:6), k = 3, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  #res_exp = eossa_exp(s, 6, cl_eps = 1e-2)
  ssa_obj <- s
  w_length <- ssa_obj$window
    U <- ssa_obj$U[,1:6]
    V <- ssa_obj$V[,1:6]
    vals <- diag(ssa_obj$sigma[1:6])
    
    P_low <- U[1:(w_length - 1),]
    P_up <- U[2:w_length,]
    M <- Rssa:::tls.solve(P_low, P_up) # Матрица сдвига
    
    dec <- eigen(M)
    #roots <- parestimate(ssa_obj, groups = list(1:ecomp_num), method = "esprit")$roots#
    roots <- dec$values
    res <- clusterize_roots(roots, 3e-2)
    print("Корни")
    print(res$roots)
    print("Кратности")
    print(res$multiplicities)
```

Этот пример также показал, что кластеризация корней бесполезна при кратных корнях с добавлением даже совсем небольшого шума. Кратности определяются неверно.

# Сравнение при одинаковом получении базиса

Здесь оставим идею с кластеризацией кратных корней здесь, просто не будем применять шум. Попробуем модифицировать обобщенный eossa, вместо жорданового базиса будем получать базис в собственном подпространстве.

```{r}
  eossa_exp2 <- function(ssa_obj, ecomp_num, cl_eps = 3e-4){
    w_length <- ssa_obj$window
    U <- ssa_obj$U[,1:ecomp_num]
    V <- ssa_obj$V[,1:ecomp_num]
    vals <- diag(ssa_obj$sigma[1:ecomp_num])
    
    P_low <- U[1:(w_length - 1),]
    P_up <- U[2:w_length,]
    M <- Rssa:::tls.solve(P_low, P_up) # Матрица сдвига
    
    dec <- eigen(M)
    #roots <- parestimate(ssa_obj, groups = list(1:ecomp_num), method = "esprit")$roots#
    roots <- dec$values
    res <- clusterize_roots(roots, cl_eps)
    print("Корни")
    print(res$roots)
    print("Кратности")
    print(res$multiplicities)
    
    print("Разложение М")
    print(eigen(M)$values)
    
    basis <- numeric(0)
    for (i in 1:length(res$multiplicities)){
      basis <- cbind(basis, get_kernel_basis(M - res$roots[[i]] * diag(nrow = nrow(M)), res$multiplicities[[i]]))
    }
    if (nrow(basis) > ncol(basis)){
      print("Wrong basis")
      return(numeric(0))
    }
    
    jordan_basis <- basis
    jordan_basis_inv <- qr.solve(jordan_basis)
    components <- list()
    
    left <- U %*% jordan_basis
    right <- numeric(0)
    if (is.complex(V))
      right <- jordan_basis_inv %*% vals %*% H(V)
    else
      right <- jordan_basis_inv %*% vals %*% t(V)
    
    prev_m <- 0
    left_side <- numeric(0)
    right_side <- numeric(0)
    
    for (i in 1:length(res$roots)){
      
      if (res$multiplicities[i] == 1){
        left_side <- matrix(left[,(1 + prev_m):(prev_m + 1)], ncol = 1)
        right_side <- matrix(right[(1 + prev_m):(prev_m + 1),], nrow = 1)
      }
      else{
        left_side <- left[,(1 + prev_m):(prev_m + res$multiplicities[i])]
        right_side <- right[(1 + prev_m):(prev_m + res$multiplicities[i]),]
      }
      
      components[[i]] <- Rssa::hankel(left_side %*% right_side)
      
      prev_m <- prev_m + res$multiplicities[i]
    }
    return(components)
  }
```

## Пример 1.

Составим для первого примера ряд, в модели которого кратности сигнальных корней небольшие. Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$. Также добавим гармонику $0.6 \mathsf{cos}(\frac{2\pi n}{4})$. 

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.6 * cos(2 * pi * j / 4))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp2(s, 4, cl_eps = 3e-2)
  
  eossa_old <- eossa(s, nested.groups = list(1:4), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Посмотрим на ошибку для обычного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, первая выделенная компонента: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, вторая выделенная компонента: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Как можно увидеть, что EOSSA для простых корней точно идентифицировал компоненты.

Теперь посмотрим на ошибки обобщенного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[1]] + res_exp[[3]] - comps[[2]]))))
```
Ошибка достаточно большая. Можно сделать вывод, что недостаточно просто найти базис собственного подпространства.

Теперь попробуем вообще сделать все то же самое (просто проверить, что все остальное работает верно).

```{r}
  eossa_exp3 <- function(ssa_obj, ecomp_num, cl_eps = 3e-4, k){
    w_length <- ssa_obj$window
    U <- ssa_obj$U[,1:ecomp_num]
    V <- ssa_obj$V[,1:ecomp_num]
    vals <- diag(ssa_obj$sigma[1:ecomp_num])
    
    P_low <- U[1:(w_length - 1),]
    P_up <- U[2:w_length,]
    M <- Rssa:::tls.solve(P_low, P_up) # Матрица сдвига
    
    dec <- eigen(M)
    #roots <- parestimate(ssa_obj, groups = list(1:ecomp_num), method = "esprit")$roots#
    roots <- dec$values
    res <- clusterize_roots(roots, cl_eps)
    print("Корни")
    print(res$roots)
    print("Кратности")
    print(res$multiplicities)
    
    print("Разложение М")
    print(eigen(M)$values)
    
    ord <- order(abs(Arg(roots)))
    roots <- roots[ord]
    M_U <- dec$vectors[, ord, drop = FALSE]
  
    d <- stats::dist(cbind(Re(roots), abs(Im(roots))), method = "euclidian") # TODO Use the proper distance from KDU
  
    hc <- hclust(d, method = "complete")
  
    idx <- cutree(hc, k = k, h = NULL)
  
    groups <- tapply(seq_along(idx), idx, identity)
    names(groups) <- paste("F", names(groups), sep = "")
  
    for (group in groups) {
      print(cbind(Re(M_U[, group, drop = FALSE]),
                                            Im(M_U[, group, drop = FALSE])))
      M_U[, group] <- svd(cbind(Re(M_U[, group, drop = FALSE]),
                                            Im(M_U[, group, drop = FALSE])),
                                      nu = length(group), nv = 0)$u
    }
  
    M_U <- Re(M_U)
    print("basis")
    print(M_U)
    print("eig basis")
    print(dec$vectors)
    
    ans <- list()
    inverted_basis <- qr.solve(M_U)
    
    left <- U %*% M_U
    right <- numeric(0)
    if (is.complex(V))
      right <- inverted_basis %*% vals %*% H(V)
    else
      right <- inverted_basis %*% vals %*% t(V)
    
    ind <- 1
    for (group in groups){
      left_side <- numeric(0)
      right_side <- numeric(0)
      if (length(group) > 1){
        left_side <- left[, group]
        right_side <- right[group, ]
      }
      else {
        left_side <- matrix(left[, group], ncol = 1)
        right_side <- matrix(right[group, ], nrow = 1)
      }
      ans[[ind]] <- Rssa:::hankel(left_side %*% right_side)
      ind <- ind + 1
    }
    return(ans)
  }
```

## Пример 1.

Составим для первого примера ряд, в модели которого кратности сигнальных корней небольшие. Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$. Также добавим гармонику $0.6 \mathsf{cos}(\frac{2\pi n}{4})$. 

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.6 * cos(2 * pi * j / 4))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp3(s, 4, cl_eps = 1e-2, k = 2)
  
  eossa_old <- eossa(s, nested.groups = list(1:4), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Посмотрим на ошибку для обычного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, первая выделенная компонента: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, вторая выделенная компонента: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Как можно увидеть, что EOSSA для простых корней точно идентифицировал компоненты.

Теперь посмотрим на ошибки обобщенного EOSSA.
```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[1]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[2]] - comps[[2]]))))
```
Компоненты найдены достаточно точно.

## Пример 2.

Посмотрим что будет, если в тренде только корень большой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 5$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. 

```{r}
  mu1 = 0.98
  
  comp1 <- function(j) {
    return((0.34 - 0.09 * j + 3e-4 * j ^ 2 - 4.5e-6 * j ^ 3 + 2.3e-8 * j ^ 4) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- comp1(time_series_stamps) + comp2(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  res_exp <- eossa_exp3(s, 7, cl_eps = 1e-2, k = 2)
  
  eossa_old <- eossa(s, nested.groups = list(1:7), k = 2, solve.method = "tls")
  res_old <- reconstruct(eossa_old, groups = eossa_old$iossa.groups)
```

Посмотрим на ошибки обычного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_old$F1 - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_old$F2 - comps[[2]]))))
```

Компоненты найдены достаточно точно.

Теперт посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, выделение тренда: ", sum(abs(res_exp[[1]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, выделение гармоники: ", sum(abs(res_exp[[2]] - comps[[2]]))))
```

Компоненты найдены достаточно точно.

## Пример 3.

Усложним задачу. Пусть теперь в можели тренда два сигнальных корня небольшой кратности.

Построим тренд с помощью корня $\mu_1 = 0.98$ кратности $m_1 = 2$ и корня $\mu_2 = 1.02$ кратности $m_2 = 2$. Также добавим гармонику $0.4 \mathsf{cos}(\frac{2\pi n}{12})$. 

```{r}
  mu1 = 0.98
  
  mu2 = 1.02
  
  comp1 <- function(j) {
    return((5.3 - 0.03 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-2.7 + 0.08 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (0.4 * cos(2 * pi * j / 12))
  }
  
  time_series <- time_series_function(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:6), k = 3, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  res_exp = eossa_exp3(s, 6, cl_eps = 1e-2, k = 3)
```

Посмотрим на ошибку для обычного EOSSA. Посмотрим насколько точно были идентифицированы компоненты тренда. Для удобства будем вычислять минимальную ошибку, сравнивая каждую выделенную компоненту с заданными компонентами.
```{r}
  min_err <- Inf
  print("Первая полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F1 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))

  min_err <- Inf

  print("Вторая полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F2 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Третья полученная компонента")
  for (i in 1:3){
    min_err <- min(min_err, sum(abs(res_old$F3 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
```

Компоненты найдены достаточно точно.

Теперь посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[1]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[2]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[3]] - comps[[3]]))))
```
Компоненты найдены достаточно точно.

Из полученных результатов можно сделать вывод, что базис, который строится в обычном EOSSA, действительно позволяет строить разложение корректно даже в случае кратных корней.

# Примеры где обобщенный все же точнее

```{r}
  mu1 = -0.92
  
  mu2 = 0.97
  
  mu3 = -1.02
  
  comp1 <- function(j) {
    return((2.5 - 0.33 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((22.9 - 0.04 * j + 4.5e-2 * j ^ 2 - 8e-4 * j ^ 3) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return((-17 + 0.13 * j) * mu3 ^ j)
  }
  
  comp4 <- function(j){
    return(4.5 * cos(2 * pi * j / 12))
  }
  
  comp5 <- function(j){
    return(4.5 * cos(2 * pi * j / 3 - pi / 3))
  }
  
  time_series_stamps2 = 1:50
  time_series <- time_series_function(time_series_stamps2) + comp4(time_series_stamps2) + comp5(time_series_stamps2)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps2)
  comps[[2]] <- comp2(time_series_stamps2)
  comps[[3]] <- comp3(time_series_stamps2)
  comps[[4]] <- comp4(time_series_stamps2)
  comps[[5]] <- comp5(time_series_stamps2)
  
  s <- ssa(time_series, L = 24, svd.method = "svd")
  plot(s)
  
  eoss <- eossa(s, nested.groups = list(1:12), k = 5, solve.method = "tls")
  res_old = reconstruct(eoss, groups = eoss$iossa.groups)
  
  res_exp = eossa_exp(s, 12, cl_eps = 3e-2)
```

Посмотрим на ошибки обычного EOSSA.

```{r}
  min_err <- Inf
  print("Первая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F1 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))

  min_err <- Inf

  print("Вторая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F2 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Третья полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F3 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
   min_err <- Inf

  print("Четвертая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F4 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
  min_err <- Inf

  print("Пятая полученная компонента")
  for (i in 1:5){
    min_err <- min(min_err, sum(abs(res_old$F5 - comps[[i]])))
  }
  print(paste0("Минимальная сумма модулей ошибок, сравнение со всеми компонентами: ", min_err))
  
```

Компоненты выделились точно.

Посмотрим на ошибки обобщенного EOSSA.

```{r}
  print(paste0("Сумма модулей ошибок, идентификация первой компоненты: ", sum(abs(res_exp[[2]] - comps[[1]]))))
  print(paste0("Сумма модулей ошибок, идентификация второй компоненты: ", sum(abs(res_exp[[3]] - comps[[2]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[1]] - comps[[3]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[6]] + res_exp[[7]] - comps[[4]]))))
  print(paste0("Сумма модулей ошибок, идентификация третьей компоненты: ", sum(abs(res_exp[[4]] + res_exp[[5]] - comps[[5]]))))
```

Компоненты выделились точнее.