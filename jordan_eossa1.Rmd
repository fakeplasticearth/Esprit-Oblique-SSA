---
title: ''
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

В этом файле хранятся функции, которые строят жорданов базис. Тестирование функций и примеры построения жорданового базиса находятся в файле jordan_research2.

```{r, message = FALSE, warning = FALSE}
  source("jordan_util.R")
  library(QZ)
```

## Реализация EOSSA для случая кратных корней

```{r}
  eossa_exp <- function(ssa_obj, ecomp_num){
    w_length <- ssa_obj$window
    U <- ssa_obj$U[,1:ecomp_num]
    V <- ssa_obj$V[,1:ecomp_num]
    vals <- diag(ssa_obj$sigma[1:ecomp_num])
    
    P_low <- U[1:(w_length - 1),]
    P_up <- U[2:w_length,]
    M <- Rssa:::tls.solve(P_low, P_up) # Матрица сдвига
    
    dec <- eigen(M)
    #roots <- parestimate(ssa_obj, groups = list(1:ecomp_num), method = "esprit")$roots#
    roots <- dec$values
    res <- clusterize_roots(roots)
    print("Корни")
    print(res$roots)
    print("Кратности")
    print(res$multiplicities)
    
    print("Разложение М")
    print(eigen(M)$values)
    
    basis <- get_all_basis(M, res$roots, res$multiplicities)
    
    jordan_basis <- basis$basis
    jordan_basis_inv <- qr.solve(jordan_basis)
    components <- list()
    
    left <- U %*% jordan_basis
    right <- jordan_basis_inv %*% vals %*% H(V)
    
    prev_m <- 0
    left_side <- numeric(0)
    right_side <- numeric(0)
    
    for (i in 1:length(res$roots)){
      
      if (res$multiplicities[i] == 1){
        left_side <- matrix(left[,(1 + prev_m):(prev_m + 1)], ncol = 1)
        right_side <- matrix(right[(1 + prev_m):(prev_m + 1),], nrow = 1)
      }
      else{
        left_side <- left[,(1 + prev_m):(prev_m + res$multiplicities[i])]
        right_side <- right[(1 + prev_m):(prev_m + res$multiplicities[i]),]
      }
      
      components[[i]] <- Rssa::hankel(left_side %*% right_side)
      
      prev_m <- prev_m + res$multiplicities[i]
    }
    return(components)
  }
```


# Пример 1
Пусть будут три различных корня $\mu_1 = 0.75 - 0.63i, \mu_2 = 0.4 + 0.9i, \mu_3 = 0.5 - 0.87i$, при этом их кратности $m_1 = 4, m_2 = 2, m_3 = 1$. Построим ряд через ЛРФ.
```{r lrts}
  mu1 = 0.75 - 0.63i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.4 + 0.9i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.5 - 0.87i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return((2.5 + 0.5 * j + 1.5 * j ^ 2 - 3.4 * j ^ 3) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ( - 2.2 * mu3 ^ j)
  }
  
  time_series_function <- function(j) {
    return (comp1(j) + comp2(j) + comp3(j))
  }
```

```{r ts}
  time_series_stamps = 0:100
  time_series <- time_series_function(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 7)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[2]]) ^ 2) / length(time_series)))
```

Компоненты нашлись верно!

## Пример 2

Три различных корня $\mu_1 = 0.2 - 0.97i, \mu_2 = 0.63 + 0.63i, \mu_3 = 0.9 - 0.5i$, при этом их кратности $m_1 = 2, m_2 = 3, m_3 = 2$.
```{r}
  mu1 = 0.2 - 0.97i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.63 + 0.63i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.9 - 0.5i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.05 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((-2.2 + 0.8 * j) * mu3 ^ j)
  }
  time_series <- time_series_function(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 7)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[2]]) ^ 2) / length(time_series)))
```
Все компоненты нашлись верно.

## Пример 3

Построим тренд с помощью корня $\mu_1 = 0.12 - 1.03i$ кратности $m_1 = 1$, корня $\mu_2 = 0.63 + 0.63i$ кратности $m_2 = 3$ и корня $m_3 = 0.9 - 0.5i$ кратности $m_3 = 2$. Также добавим гармонику $0.5 \mathsf{cos}(\frac{2\pi n}{3})$.

```{r}
  mu1 = 0.12 - 1.03i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.63 + 0.63i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.9 - 0.5i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return(0.2 * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((0.7 - 0.08 * j) * mu3 ^ j)
  }
  
  comp4 <- function(j) {
    return (0.5 * cos(2 * pi * j / 3))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  #Parestimate почему-то здесь находит корни неточно
  get_roots_par(s, 3)
  plot(s)
  plot(s, type = "vectors", idx = 1:8)
  
  res <- eossa_exp(s, 8)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[5]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[5]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 4
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] + res[[4]] - comps[[4]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] + res[[4]] - comps[[4]]) ^ 2) / length(time_series)))
```

Компоненты выделились верно.

## Пример 4. Проверка обычного EOSSA
```{r}
  mu12 = 0.88 - 0.4i
  print(paste0("mu_1: ", mu12, ", Mod: ", Mod(mu12)))
  
  mu22 = 0.3 + 0.89i
  print(paste0("mu_2: ", mu22, ", Mod: ", Mod(mu22)))
  
  mu32 = 1.01 + 0.05i
  print(paste0("mu_3: ", mu32, ", Mod: ", Mod(mu32)))
  
  comp12 <- function(j) {
    return( -0.5 * mu12 ^ j)
  }
  
  comp22 <- function(j) {
    return(1.5 * mu22 ^ j)
  }
  
  comp32 <- function(j) {
    return ( - 0.02 * mu32 ^ j)
  }
  
  time_series_stamps = 0:100
  comps <- list()
  comps[[3]] <- comp12(time_series_stamps)
  comps[[2]] <- comp22(time_series_stamps)
  comps[[1]] <- comp32(time_series_stamps)

  time_series_function2 <- function(j){
    return (comp12(j) + comp22(j) + comp32(j))
  }  

  time_series2 <- time_series_function2(time_series_stamps)
  
  s2 <- ssa(time_series2, L = 48, svd.method = "svd")
  res <- eossa_exp(s2, 3)
  
  for (i in 1:length(res)){
    comp <- res[[i]]
    print(paste0("MSE: ", sum(abs(comps[[i]] - comp) ^ 2) / length(comp)))
  }
  
```

## Пример 5. Проверка обычного EOSSA
```{r}
  mu1 = 0.5 - 0.93i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.72 + 0.7i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.74 - 0.62i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  comp1 <- function(j) {
    return(0.5 * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return(-1.2 * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ( - 2.2 * mu3 ^ j)
  }
  
  time_series <- time_series_function(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  res <- eossa_exp(s, 3)
```

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компоненты нашлись верно.

## Пример 6.

Попробуем посмотреть на разделение, когда размеры матрицы сдвига будут достаточно большими. Этот случай важен, так как при больших
размерах матрицы базис строится менее точно.

Построим тренд с помощью корня $\mu_1 = 0.24 - 0.93i$ кратности $m_1 = 2$, корня $\mu_2 = 0.72 + 0.7i$ кратности $m_2 = 3$, корня $m_3 = 0.5 - 0.865i$ кратности $m_3 = 2$ и корня $m_4 = 0.13 + 1.02i$ кратности $m_4 = 2$. Также добавим гармоники $0.5 \mathsf{cos}(\frac{2\pi n}{3})$ и $0.5 \mathsf{cos}(\frac{2\pi n}{4} + \frac{\pi}{2})$.

```{r}
  mu1 = 0.24 - 0.93i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.72 + 0.7i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  mu3 = 0.5 - 0.865i
  print(paste0("mu_3: ", mu3, ", Mod: ", Mod(mu3)))
  
  mu4 = 0.13 + 1.02i
  print(paste0("mu_3: ", mu4, ", Mod: ", Mod(mu4)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.05 * j) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 1.1 * j - 0.4 * j ^ 2) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return ((-2.2 + 0.8 * j) * mu3 ^ j)
  }
  
  comp4 <- function(j) {
    return ((0.56 - 0.68 * j) * mu4 ^ j)
  }
  
  comp5 <- function(j) {
    return (0.5 * cos(2 * pi * j / 3))
  }
  
  comp6 <- function(j) {
    return (0.5 * cos(2 * pi * j / 4 + pi / 2))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps) + comp5(time_series_stamps) + comp6(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  comps[[5]] <- comp5(time_series_stamps)
  comps[[6]] <- comp6(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  res <- eossa_exp(s, 13)

```

В этом примере, кстати, есть недостаток разделимости компонент.

Ошибки выделения компонент

Компонента 1
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[2]] - comps[[1]]))))
  print(paste0("MSE: ", sum(abs(res[[2]] - comps[[1]]) ^ 2) / length(time_series)))
```
Компонента 2
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[8]] - comps[[2]]))))
  print(paste0("MSE: ", sum(abs(res[[8]] - comps[[2]]) ^ 2) / length(time_series)))
```
Компонента 3
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[3]] - comps[[3]]))))
  print(paste0("MSE: ", sum(abs(res[[3]] - comps[[3]]) ^ 2) / length(time_series)))
```
Компонента 4
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[1]] - comps[[4]]))))
  print(paste0("MSE: ", sum(abs(res[[1]] - comps[[4]]) ^ 2) / length(time_series)))
```
Компонента 5
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[4]] + res[[7]] - comps[[5]]))))
  print(paste0("MSE: ", sum(abs(res[[4]] + res[[7]] - comps[[5]]) ^ 2) / length(time_series)))
```
Компонента 6
```{r}
  print(paste0("Сумма модулей ошибки: ", sum(abs(res[[5]] + res[[6]] - comps[[6]]))))
  print(paste0("MSE: ", sum(abs(res[[5]] + res[[6]] - comps[[6]]) ^ 2) / length(time_series)))
```
Все компоненты нашлись верно.

## Пример 7.

Теперь попробуем посмотреть на разделение, когда размеры матрицы сдвига будут достаточно большими и при этом кратность одного корня тоже будет велика. Этот случай важен, так как при большой кратности корня матрица возводится в большую степень, соответственно ранг матрицы тяжелее оценить.

Построим тренд с помощью корня $\mu_1 = 0.74 - 0.65i$ кратности $m_1 = 6$ и корня $\mu_2 = 0.23 + 0.95i$ кратности $m_2 = 2$. Также добавим гармоники $-0.3 \mathsf{cos}(\frac{2\pi n}{6})$ и $-0.3 \mathsf{cos}(\frac{2\pi n}{3} + \frac{\pi}{4})$.

```{r}
  mu1 = 0.74 - 0.65i
  print(paste0("mu_1: ", mu1, ", Mod: ", Mod(mu1)))
  
  mu2 = 0.23 + 0.95i
  print(paste0("mu_2: ", mu2, ", Mod: ", Mod(mu2)))
  
  comp1 <- function(j) {
    return((-1.3 + 0.2 * j - 0.001 * j ^ 2 + 9e-4 * j ^ 3 - 2e-5 * j ^ 4 + 1.2e-7 * j ^ 5) * mu1 ^ j)
  }
  
  comp2 <- function(j) {
    return((-1.2 + 0.11 * j) * mu2 ^ j)
  }
  
  comp3 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 6))
  }
  
  comp4 <- function(j) {
    return (-0.3 * cos(2 * pi * j / 3 + pi / 4))
  }
  
  time_series <- time_series_function(time_series_stamps) + comp4(time_series_stamps)
  comps <- list()
  comps[[1]] <- comp1(time_series_stamps)
  comps[[2]] <- comp2(time_series_stamps)
  comps[[3]] <- comp3(time_series_stamps)
  comps[[4]] <- comp4(time_series_stamps)
  
  s <- ssa(time_series, L = 48, svd.method = "svd")
  plot(s)
  print(get_roots_eig(s, 12)$roots)
  print(get_roots_eig(s, 12)$multiplicities)
  print(paste0("Расстояние между корнями: ", Mod(0.7392588-0.6497611i - (0.7407396-0.6502349i))))
  alg_root <- mean(c(0.7392588-0.6497611i, 0.7398371-0.6492407i, 0.7394233-0.6505245i, 0.7405740-0.6494789i, 0.7401672-0.6507600i, 0.7407396-0.6502349i))
  print(paste0("Корень при увеличении eps: ", alg_root))
  #res <- eossa_exp(s, 12)
```

Этот пример показал, что нужно увеличить eps для отбора корней в кластер, когда кратность корня большая. Однако мы не можем заранее сказать максимальную кратность корня, поэтому необходимо как-то разумно подобрать eps, а также сделать это параметром алгоритма.

Расстояния между корнями разные. Влияет действительно только кратность, чем больше, тем больше расстояния. При этом если правильно составить кластер, корень найдется точно.

Крайне интересные корни получились у гармоник, образуют квадрат (как вообще разделять??)

## Планы

1. Научиться точнее вычислять кратные корни (получается, вообще точнее любые корни вычислять???)
2. Доделать разделение для корней с большой кратностью.
3. А что будет если сделать ошибку в вычислении кратного корня, насколько поменяется ошибка?
4. Здесь гармоники объединены вручную после разделения, необходимо будет потом автоматизировать это.
4.1. Разобрать случай с гармониками с наложением и с гармониками "квадратом".
